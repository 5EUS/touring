// Generated by `wit-bindgen` 0.45.0. DO NOT EDIT!
// Options used:
/// -------------------- Types --------------------
#[derive(Clone)]
pub enum MediaType {
  Anime,
  Manga,
  Other(_rt::String),
}
impl ::core::fmt::Debug for MediaType {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    match self {
      MediaType::Anime => {
        f.debug_tuple("MediaType::Anime").finish()
      }
      MediaType::Manga => {
        f.debug_tuple("MediaType::Manga").finish()
      }
      MediaType::Other(e) => {
        f.debug_tuple("MediaType::Other").field(e).finish()
      }
    }
  }
}
#[derive(Clone)]
pub struct Media {
  pub id: _rt::String,
  pub mediatype: MediaType,
  pub title: _rt::String,
  pub description: Option<_rt::String>,
  /// Link to the media page on the provider
  pub url: Option<_rt::String>,
  /// Optional cover/thumbnail image URL
  pub cover_url: Option<_rt::String>,
}
impl ::core::fmt::Debug for Media {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    f.debug_struct("Media").field("id", &self.id).field("mediatype", &self.mediatype).field("title", &self.title).field("description", &self.description).field("url", &self.url).field("cover-url", &self.cover_url).finish()
  }
}
/// Neutral unit representing a serializable subdivision of a media item.
/// Example: chapter (manga/comic), episode (anime/tv), section (book/textbook).
#[derive(Clone)]
pub enum UnitKind {
  Chapter,
  Episode,
  Section,
  Other(_rt::String),
}
impl ::core::fmt::Debug for UnitKind {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    match self {
      UnitKind::Chapter => {
        f.debug_tuple("UnitKind::Chapter").finish()
      }
      UnitKind::Episode => {
        f.debug_tuple("UnitKind::Episode").finish()
      }
      UnitKind::Section => {
        f.debug_tuple("UnitKind::Section").finish()
      }
      UnitKind::Other(e) => {
        f.debug_tuple("UnitKind::Other").field(e).finish()
      }
    }
  }
}
#[derive(Clone)]
pub struct Unit {
  pub id: _rt::String,
  pub title: _rt::String,
  /// Raw ordinal label as provided by the source (e.g. "12.5", "Part II")
  pub number_text: Option<_rt::String>,
  /// Parsed numeric ordinal for sorting when available
  pub number: Option<f32>,
  /// ISO language code (e.g. "en")
  pub lang: Option<_rt::String>,
  /// Optional grouping label such as volume/season/part
  pub group: Option<_rt::String>,
  /// Optional direct link to the unit page
  pub url: Option<_rt::String>,
  /// RFC3339/ISO8601 timestamp string if available
  pub published_at: Option<_rt::String>,
  /// The unit kind
  pub kind: UnitKind,
}
impl ::core::fmt::Debug for Unit {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    f.debug_struct("Unit").field("id", &self.id).field("title", &self.title).field("number-text", &self.number_text).field("number", &self.number).field("lang", &self.lang).field("group", &self.group).field("url", &self.url).field("published-at", &self.published_at).field("kind", &self.kind).finish()
  }
}
/// Generic asset exposed by a unit (page/image/audio/video/subtitle/file links).
#[derive(Clone)]
pub enum AssetKind {
  Page,
  Image,
  Audio,
  Video,
  Subtitle,
  File,
  Other(_rt::String),
}
impl ::core::fmt::Debug for AssetKind {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    match self {
      AssetKind::Page => {
        f.debug_tuple("AssetKind::Page").finish()
      }
      AssetKind::Image => {
        f.debug_tuple("AssetKind::Image").finish()
      }
      AssetKind::Audio => {
        f.debug_tuple("AssetKind::Audio").finish()
      }
      AssetKind::Video => {
        f.debug_tuple("AssetKind::Video").finish()
      }
      AssetKind::Subtitle => {
        f.debug_tuple("AssetKind::Subtitle").finish()
      }
      AssetKind::File => {
        f.debug_tuple("AssetKind::File").finish()
      }
      AssetKind::Other(e) => {
        f.debug_tuple("AssetKind::Other").field(e).finish()
      }
    }
  }
}
#[derive(Clone)]
pub struct Asset {
  /// Direct URL to the asset
  pub url: _rt::String,
  /// Optional MIME type
  pub mime: Option<_rt::String>,
  /// Optional pixel width/height (for visual assets)
  pub width: Option<u32>,
  pub height: Option<u32>,
  /// Kind of asset
  pub kind: AssetKind,
}
impl ::core::fmt::Debug for Asset {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    f.debug_struct("Asset").field("url", &self.url).field("mime", &self.mime).field("width", &self.width).field("height", &self.height).field("kind", &self.kind).finish()
  }
}
/// Provider capability advertisement for adaptive host behavior.
#[derive(Clone)]
pub struct ProviderCapabilities {
  pub media_types: _rt::Vec::<MediaType>,
  pub unit_kinds: _rt::Vec::<UnitKind>,
  pub asset_kinds: _rt::Vec::<AssetKind>,
}
impl ::core::fmt::Debug for ProviderCapabilities {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    f.debug_struct("ProviderCapabilities").field("media-types", &self.media_types).field("unit-kinds", &self.unit_kinds).field("asset-kinds", &self.asset_kinds).finish()
  }
}
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchmedialist_cabi<T: Guest>(arg0: i32,arg1: *mut u8,arg2: usize,arg3: *mut u8,arg4: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result3 = {
  let v1 = match arg0 {
    0 => {
      MediaType::Anime
    }
    1 => {
      MediaType::Manga
    }
    n => {
      debug_assert_eq!(n, 2, "invalid enum discriminant");
      let e1 = {
        let len0 = arg2;
        let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);

        _rt::string_lift(bytes0)
      };
      MediaType::Other(e1)
    }
  };
  let len2 = arg4;
  let bytes2 = _rt::Vec::from_raw_parts(arg3.cast(), len2, len2);
  T::fetchmedialist(v1, _rt::string_lift(bytes2))
};
let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
let vec12 = result3;
let len12 = vec12.len();
let layout12 = _rt::alloc::Layout::from_size_align(vec12.len() * (16*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
let (result12, _cleanup12) = wit_bindgen::rt::Cleanup::new(layout12);if let Some(cleanup) = _cleanup12 { cleanup.forget(); }
for (i, e) in vec12.into_iter().enumerate() {
  let base = result12.add(i * (16*::core::mem::size_of::<*const u8>()));
  {
    let Media{ id:id5, mediatype:mediatype5, title:title5, description:description5, url:url5, cover_url:cover_url5, } = e;
    let vec6 = (id5.into_bytes()).into_boxed_slice();
    let ptr6 = vec6.as_ptr().cast::<u8>();
    let len6 = vec6.len();
    ::core::mem::forget(vec6);
    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
    *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
    match mediatype5 {
      MediaType::Anime=> {
        {
          *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      }
      MediaType::Manga=> {
        {
          *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        }
      }
      MediaType::Other(e) => {
        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
        let vec7 = (e.into_bytes()).into_boxed_slice();
        let ptr7 = vec7.as_ptr().cast::<u8>();
        let len7 = vec7.len();
        ::core::mem::forget(vec7);
        *base.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
        *base.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
      },
    }
    let vec8 = (title5.into_bytes()).into_boxed_slice();
    let ptr8 = vec8.as_ptr().cast::<u8>();
    let len8 = vec8.len();
    ::core::mem::forget(vec8);
    *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
    *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
    match description5 {
      Some(e) => {
        *base.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec9 = (e.into_bytes()).into_boxed_slice();
        let ptr9 = vec9.as_ptr().cast::<u8>();
        let len9 = vec9.len();
        ::core::mem::forget(vec9);
        *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
        *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
      },
      None => {
        {
          *base.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match url5 {
      Some(e) => {
        *base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec10 = (e.into_bytes()).into_boxed_slice();
        let ptr10 = vec10.as_ptr().cast::<u8>();
        let len10 = vec10.len();
        ::core::mem::forget(vec10);
        *base.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
        *base.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
      },
      None => {
        {
          *base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match cover_url5 {
      Some(e) => {
        *base.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec11 = (e.into_bytes()).into_boxed_slice();
        let ptr11 = vec11.as_ptr().cast::<u8>();
        let len11 = vec11.len();
        ::core::mem::forget(vec11);
        *base.add(15*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
        *base.add(14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
      },
      None => {
        {
          *base.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };}
  }
  *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
  *ptr4.add(0).cast::<*mut u8>() = result12;
  ptr4
} }
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchmedialist<T: Guest>(arg0: *mut u8,) { unsafe {
  let l0 = *arg0.add(0).cast::<*mut u8>();
  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
  let base18 = l0;
  let len18 = l1;
  for i in 0..len18 {
    let base = base18.add(i * (16*::core::mem::size_of::<*const u8>()));
    {
      let l2 = *base.add(0).cast::<*mut u8>();
      let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
      _rt::cabi_dealloc(l2, l3, 1);
      let l4 = i32::from(*base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l4 {
        0 => (),
        1 => (),
        _ => {
          let l5 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l6 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l5, l6, 1);
        },
      }
      let l7 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
      let l8 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
      _rt::cabi_dealloc(l7, l8, 1);
      let l9 = i32::from(*base.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l9 {
        0 => (),
        _ => {
          let l10 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l11 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l10, l11, 1);
        },
      }
      let l12 = i32::from(*base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l12 {
        0 => (),
        _ => {
          let l13 = *base.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l14 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l13, l14, 1);
        },
      }
      let l15 = i32::from(*base.add(13*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l15 {
        0 => (),
        _ => {
          let l16 = *base.add(14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l17 = *base.add(15*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l16, l17, 1);
        },
      }
    }
  }
  _rt::cabi_dealloc(base18, len18 * (16*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
} }
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchunits_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result1 = {
  let len0 = arg1;
  let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
  T::fetchunits(_rt::string_lift(bytes0))
};
let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
let vec12 = result1;
let len12 = vec12.len();
let layout12 = _rt::alloc::Layout::from_size_align(vec12.len() * (8+22*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
let (result12, _cleanup12) = wit_bindgen::rt::Cleanup::new(layout12);if let Some(cleanup) = _cleanup12 { cleanup.forget(); }
for (i, e) in vec12.into_iter().enumerate() {
  let base = result12.add(i * (8+22*::core::mem::size_of::<*const u8>()));
  {
    let Unit{ id:id3, title:title3, number_text:number_text3, number:number3, lang:lang3, group:group3, url:url3, published_at:published_at3, kind:kind3, } = e;
    let vec4 = (id3.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
    *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
    let vec5 = (title3.into_bytes()).into_boxed_slice();
    let ptr5 = vec5.as_ptr().cast::<u8>();
    let len5 = vec5.len();
    ::core::mem::forget(vec5);
    *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
    *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
    match number_text3 {
      Some(e) => {
        *base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec6 = (e.into_bytes()).into_boxed_slice();
        let ptr6 = vec6.as_ptr().cast::<u8>();
        let len6 = vec6.len();
        ::core::mem::forget(vec6);
        *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
        *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
      },
      None => {
        {
          *base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match number3 {
      Some(e) => {
        *base.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        *base.add(4+7*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
      },
      None => {
        {
          *base.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match lang3 {
      Some(e) => {
        *base.add(8+7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec7 = (e.into_bytes()).into_boxed_slice();
        let ptr7 = vec7.as_ptr().cast::<u8>();
        let len7 = vec7.len();
        ::core::mem::forget(vec7);
        *base.add(8+9*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
        *base.add(8+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
      },
      None => {
        {
          *base.add(8+7*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match group3 {
      Some(e) => {
        *base.add(8+10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec8 = (e.into_bytes()).into_boxed_slice();
        let ptr8 = vec8.as_ptr().cast::<u8>();
        let len8 = vec8.len();
        ::core::mem::forget(vec8);
        *base.add(8+12*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
        *base.add(8+11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr8.cast_mut();
      },
      None => {
        {
          *base.add(8+10*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match url3 {
      Some(e) => {
        *base.add(8+13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec9 = (e.into_bytes()).into_boxed_slice();
        let ptr9 = vec9.as_ptr().cast::<u8>();
        let len9 = vec9.len();
        ::core::mem::forget(vec9);
        *base.add(8+15*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
        *base.add(8+14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
      },
      None => {
        {
          *base.add(8+13*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match published_at3 {
      Some(e) => {
        *base.add(8+16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec10 = (e.into_bytes()).into_boxed_slice();
        let ptr10 = vec10.as_ptr().cast::<u8>();
        let len10 = vec10.len();
        ::core::mem::forget(vec10);
        *base.add(8+18*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
        *base.add(8+17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10.cast_mut();
      },
      None => {
        {
          *base.add(8+16*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match kind3 {
      UnitKind::Chapter=> {
        {
          *base.add(8+19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      }
      UnitKind::Episode=> {
        {
          *base.add(8+19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        }
      }
      UnitKind::Section=> {
        {
          *base.add(8+19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
        }
      }
      UnitKind::Other(e) => {
        *base.add(8+19*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
        let vec11 = (e.into_bytes()).into_boxed_slice();
        let ptr11 = vec11.as_ptr().cast::<u8>();
        let len11 = vec11.len();
        ::core::mem::forget(vec11);
        *base.add(8+21*::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
        *base.add(8+20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11.cast_mut();
      },
    }
  }
}
*ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
*ptr2.add(0).cast::<*mut u8>() = result12;
ptr2
} }
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchunits<T: Guest>(arg0: *mut u8,) { unsafe {
  let l0 = *arg0.add(0).cast::<*mut u8>();
  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
  let base24 = l0;
  let len24 = l1;
  for i in 0..len24 {
    let base = base24.add(i * (8+22*::core::mem::size_of::<*const u8>()));
    {
      let l2 = *base.add(0).cast::<*mut u8>();
      let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
      _rt::cabi_dealloc(l2, l3, 1);
      let l4 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
      let l5 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
      _rt::cabi_dealloc(l4, l5, 1);
      let l6 = i32::from(*base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l6 {
        0 => (),
        _ => {
          let l7 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l8 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l7, l8, 1);
        },
      }
      let l9 = i32::from(*base.add(8+7*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l9 {
        0 => (),
        _ => {
          let l10 = *base.add(8+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l11 = *base.add(8+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l10, l11, 1);
        },
      }
      let l12 = i32::from(*base.add(8+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l12 {
        0 => (),
        _ => {
          let l13 = *base.add(8+11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l14 = *base.add(8+12*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l13, l14, 1);
        },
      }
      let l15 = i32::from(*base.add(8+13*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l15 {
        0 => (),
        _ => {
          let l16 = *base.add(8+14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l17 = *base.add(8+15*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l16, l17, 1);
        },
      }
      let l18 = i32::from(*base.add(8+16*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l18 {
        0 => (),
        _ => {
          let l19 = *base.add(8+17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l20 = *base.add(8+18*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l19, l20, 1);
        },
      }
      let l21 = i32::from(*base.add(8+19*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l21 {
        0 => (),
        1 => (),
        2 => (),
        _ => {
          let l22 = *base.add(8+20*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l23 = *base.add(8+21*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l22, l23, 1);
        },
      }
    }
  }
  _rt::cabi_dealloc(base24, len24 * (8+22*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
} }
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchassets_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result1 = {
  let len0 = arg1;
  let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
  T::fetchassets(_rt::string_lift(bytes0))
};
let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
let vec7 = result1;
let len7 = vec7.len();
let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (16+8*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);if let Some(cleanup) = _cleanup7 { cleanup.forget(); }
for (i, e) in vec7.into_iter().enumerate() {
  let base = result7.add(i * (16+8*::core::mem::size_of::<*const u8>()));
  {
    let Asset{ url:url3, mime:mime3, width:width3, height:height3, kind:kind3, } = e;
    let vec4 = (url3.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
    *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
    match mime3 {
      Some(e) => {
        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        let vec5 = (e.into_bytes()).into_boxed_slice();
        let ptr5 = vec5.as_ptr().cast::<u8>();
        let len5 = vec5.len();
        ::core::mem::forget(vec5);
        *base.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
        *base.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
      },
      None => {
        {
          *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match width3 {
      Some(e) => {
        *base.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        *base.add(4+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
      },
      None => {
        {
          *base.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match height3 {
      Some(e) => {
        *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        *base.add(12+5*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
      },
      None => {
        {
          *base.add(8+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      },
    };match kind3 {
      AssetKind::Page=> {
        {
          *base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
        }
      }
      AssetKind::Image=> {
        {
          *base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
        }
      }
      AssetKind::Audio=> {
        {
          *base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
        }
      }
      AssetKind::Video=> {
        {
          *base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
        }
      }
      AssetKind::Subtitle=> {
        {
          *base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
        }
      }
      AssetKind::File=> {
        {
          *base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32) as u8;
        }
      }
      AssetKind::Other(e) => {
        *base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32) as u8;
        let vec6 = (e.into_bytes()).into_boxed_slice();
        let ptr6 = vec6.as_ptr().cast::<u8>();
        let len6 = vec6.len();
        ::core::mem::forget(vec6);
        *base.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
        *base.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr6.cast_mut();
      },
    }
  }
}
*ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
*ptr2.add(0).cast::<*mut u8>() = result7;
ptr2
} }
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchassets<T: Guest>(arg0: *mut u8,) { unsafe {
  let l0 = *arg0.add(0).cast::<*mut u8>();
  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
  let base10 = l0;
  let len10 = l1;
  for i in 0..len10 {
    let base = base10.add(i * (16+8*::core::mem::size_of::<*const u8>()));
    {
      let l2 = *base.add(0).cast::<*mut u8>();
      let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
      _rt::cabi_dealloc(l2, l3, 1);
      let l4 = i32::from(*base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l4 {
        0 => (),
        _ => {
          let l5 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l6 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l5, l6, 1);
        },
      }
      let l7 = i32::from(*base.add(16+5*::core::mem::size_of::<*const u8>()).cast::<u8>());
      match l7 {
        0 => (),
        1 => (),
        2 => (),
        3 => (),
        4 => (),
        5 => (),
        _ => {
          let l8 = *base.add(16+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l9 = *base.add(16+7*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l8, l9, 1);
        },
      }
    }
  }
  _rt::cabi_dealloc(base10, len10 * (16+8*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
} }
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_getcapabilities_cabi<T: Guest>() -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
_rt::run_ctors_once();let result0 = {
  T::getcapabilities()
};
let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
let ProviderCapabilities{ media_types:media_types2, unit_kinds:unit_kinds2, asset_kinds:asset_kinds2, } = result0;
let vec4 = media_types2;
let len4 = vec4.len();
let layout4 = _rt::alloc::Layout::from_size_align(vec4.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
let (result4, _cleanup4) = wit_bindgen::rt::Cleanup::new(layout4);if let Some(cleanup) = _cleanup4 { cleanup.forget(); }
for (i, e) in vec4.into_iter().enumerate() {
  let base = result4.add(i * (3*::core::mem::size_of::<*const u8>()));
  {
    match e {
      MediaType::Anime=> {
        {
          *base.add(0).cast::<u8>() = (0i32) as u8;
        }
      }
      MediaType::Manga=> {
        {
          *base.add(0).cast::<u8>() = (1i32) as u8;
        }
      }
      MediaType::Other(e) => {
        *base.add(0).cast::<u8>() = (2i32) as u8;
        let vec3 = (e.into_bytes()).into_boxed_slice();
        let ptr3 = vec3.as_ptr().cast::<u8>();
        let len3 = vec3.len();
        ::core::mem::forget(vec3);
        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
        *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
      },
    }
  }
}
*ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
*ptr1.add(0).cast::<*mut u8>() = result4;
let vec6 = unit_kinds2;
let len6 = vec6.len();
let layout6 = _rt::alloc::Layout::from_size_align(vec6.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
let (result6, _cleanup6) = wit_bindgen::rt::Cleanup::new(layout6);if let Some(cleanup) = _cleanup6 { cleanup.forget(); }
for (i, e) in vec6.into_iter().enumerate() {
  let base = result6.add(i * (3*::core::mem::size_of::<*const u8>()));
  {
    match e {
      UnitKind::Chapter=> {
        {
          *base.add(0).cast::<u8>() = (0i32) as u8;
        }
      }
      UnitKind::Episode=> {
        {
          *base.add(0).cast::<u8>() = (1i32) as u8;
        }
      }
      UnitKind::Section=> {
        {
          *base.add(0).cast::<u8>() = (2i32) as u8;
        }
      }
      UnitKind::Other(e) => {
        *base.add(0).cast::<u8>() = (3i32) as u8;
        let vec5 = (e.into_bytes()).into_boxed_slice();
        let ptr5 = vec5.as_ptr().cast::<u8>();
        let len5 = vec5.len();
        ::core::mem::forget(vec5);
        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
        *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5.cast_mut();
      },
    }
  }
}
*ptr1.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
*ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result6;
let vec8 = asset_kinds2;
let len8 = vec8.len();
let layout8 = _rt::alloc::Layout::from_size_align(vec8.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
let (result8, _cleanup8) = wit_bindgen::rt::Cleanup::new(layout8);if let Some(cleanup) = _cleanup8 { cleanup.forget(); }
for (i, e) in vec8.into_iter().enumerate() {
  let base = result8.add(i * (3*::core::mem::size_of::<*const u8>()));
  {
    match e {
      AssetKind::Page=> {
        {
          *base.add(0).cast::<u8>() = (0i32) as u8;
        }
      }
      AssetKind::Image=> {
        {
          *base.add(0).cast::<u8>() = (1i32) as u8;
        }
      }
      AssetKind::Audio=> {
        {
          *base.add(0).cast::<u8>() = (2i32) as u8;
        }
      }
      AssetKind::Video=> {
        {
          *base.add(0).cast::<u8>() = (3i32) as u8;
        }
      }
      AssetKind::Subtitle=> {
        {
          *base.add(0).cast::<u8>() = (4i32) as u8;
        }
      }
      AssetKind::File=> {
        {
          *base.add(0).cast::<u8>() = (5i32) as u8;
        }
      }
      AssetKind::Other(e) => {
        *base.add(0).cast::<u8>() = (6i32) as u8;
        let vec7 = (e.into_bytes()).into_boxed_slice();
        let ptr7 = vec7.as_ptr().cast::<u8>();
        let len7 = vec7.len();
        ::core::mem::forget(vec7);
        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
        *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
      },
    }
  }
}
*ptr1.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
*ptr1.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result8;
ptr1
} }
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_getcapabilities<T: Guest>(arg0: *mut u8,) { unsafe {
  let l0 = *arg0.add(0).cast::<*mut u8>();
  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
  let base5 = l0;
  let len5 = l1;
  for i in 0..len5 {
    let base = base5.add(i * (3*::core::mem::size_of::<*const u8>()));
    {
      let l2 = i32::from(*base.add(0).cast::<u8>());
      match l2 {
        0 => (),
        1 => (),
        _ => {
          let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l4 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l3, l4, 1);
        },
      }
    }
  }
  _rt::cabi_dealloc(base5, len5 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
  let l6 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
  let l7 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
  let base11 = l6;
  let len11 = l7;
  for i in 0..len11 {
    let base = base11.add(i * (3*::core::mem::size_of::<*const u8>()));
    {
      let l8 = i32::from(*base.add(0).cast::<u8>());
      match l8 {
        0 => (),
        1 => (),
        2 => (),
        _ => {
          let l9 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l10 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l9, l10, 1);
        },
      }
    }
  }
  _rt::cabi_dealloc(base11, len11 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
  let l12 = *arg0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
  let l13 = *arg0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
  let base17 = l12;
  let len17 = l13;
  for i in 0..len17 {
    let base = base17.add(i * (3*::core::mem::size_of::<*const u8>()));
    {
      let l14 = i32::from(*base.add(0).cast::<u8>());
      match l14 {
        0 => (),
        1 => (),
        2 => (),
        3 => (),
        4 => (),
        5 => (),
        _ => {
          let l15 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l16 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          _rt::cabi_dealloc(l15, l16, 1);
        },
      }
    }
  }
  _rt::cabi_dealloc(base17, len17 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
} }
pub trait Guest {
  /// Generic media discovery for any supported media type.
  /// Implementors should return an empty list for unsupported types.
  #[allow(async_fn_in_trait)]
  fn fetchmedialist(kind: MediaType,query: _rt::String,) -> _rt::Vec::<Media>;
  /// Generic unit listing for a given media id (e.g. chapters, episodes, sections).
  #[allow(async_fn_in_trait)]
  fn fetchunits(mediaid: _rt::String,) -> _rt::Vec::<Unit>;
  /// Generic asset retrieval for a given unit id (e.g. pages, images, streams, files).
  #[allow(async_fn_in_trait)]
  fn fetchassets(unitid: _rt::String,) -> _rt::Vec::<Asset>;
  /// Report provider capabilities so the host can adapt behavior.
  #[allow(async_fn_in_trait)]
  fn getcapabilities() -> ProviderCapabilities;
}
#[doc(hidden)]

macro_rules! __export_world_library_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[unsafe(export_name = "fetchmedialist")]
    unsafe extern "C" fn export_fetchmedialist(arg0: i32,arg1: *mut u8,arg2: usize,arg3: *mut u8,arg4: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchmedialist_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4) }
    }
    #[unsafe(export_name = "cabi_post_fetchmedialist")]
    unsafe extern "C" fn _post_return_fetchmedialist(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchmedialist::<$ty>(arg0) }
    }
    #[unsafe(export_name = "fetchunits")]
    unsafe extern "C" fn export_fetchunits(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchunits_cabi::<$ty>(arg0, arg1) }
    }
    #[unsafe(export_name = "cabi_post_fetchunits")]
    unsafe extern "C" fn _post_return_fetchunits(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchunits::<$ty>(arg0) }
    }
    #[unsafe(export_name = "fetchassets")]
    unsafe extern "C" fn export_fetchassets(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchassets_cabi::<$ty>(arg0, arg1) }
    }
    #[unsafe(export_name = "cabi_post_fetchassets")]
    unsafe extern "C" fn _post_return_fetchassets(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchassets::<$ty>(arg0) }
    }
    #[unsafe(export_name = "getcapabilities")]
    unsafe extern "C" fn export_getcapabilities() -> *mut u8 {
      unsafe { $($path_to_types)*::_export_getcapabilities_cabi::<$ty>() }
    }
    #[unsafe(export_name = "cabi_post_getcapabilities")]
    unsafe extern "C" fn _post_return_getcapabilities(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_getcapabilities::<$ty>(arg0) }
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_world_library_cabi;

#[cfg_attr(target_pointer_width="64", repr(align(8)))]
#[cfg_attr(target_pointer_width="32", repr(align(4)))]
struct _RetArea([::core::mem::MaybeUninit::<u8>; 6*::core::mem::size_of::<*const u8>()]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 6*::core::mem::size_of::<*const u8>()]);
mod _rt {
  #![allow(dead_code, clippy::all)]
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;

  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub use alloc_crate::alloc;
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  
  pub fn as_f32<T: AsF32>(t: T) -> f32 {
    t.as_f32()
  }

  pub trait AsF32 {
    fn as_f32(self) -> f32;
  }

  impl<'a, T: Copy + AsF32> AsF32 for &'a T {
    fn as_f32(self) -> f32 {
      (*self).as_f32()
    }
  }
  
  impl AsF32 for f32 {
    #[inline]
    fn as_f32(self) -> f32 {
      self as f32
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_library_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::__export_world_library_cabi!($ty with_types_in $($path_to_types_root)*);
  )
}
#[doc(inline)]
pub(crate) use __export_library_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.45.0:touring:library:library:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 747] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xed\x04\x01A\x02\x01\
A\x1f\x01q\x03\x05anime\0\0\x05manga\0\0\x05other\x01s\0\x03\0\x0amedia-type\x03\
\0\0\x01ks\x01r\x06\x02ids\x09mediatype\x01\x05titles\x0bdescription\x02\x03url\x02\
\x09cover-url\x02\x03\0\x05media\x03\0\x03\x01q\x04\x07chapter\0\0\x07episode\0\0\
\x07section\0\0\x05other\x01s\0\x03\0\x09unit-kind\x03\0\x05\x01kv\x01r\x09\x02i\
ds\x05titles\x0bnumber-text\x02\x06number\x07\x04lang\x02\x05group\x02\x03url\x02\
\x0cpublished-at\x02\x04kind\x06\x03\0\x04unit\x03\0\x08\x01q\x07\x04page\0\0\x05\
image\0\0\x05audio\0\0\x05video\0\0\x08subtitle\0\0\x04file\0\0\x05other\x01s\0\x03\
\0\x0aasset-kind\x03\0\x0a\x01ky\x01r\x05\x03urls\x04mime\x02\x05width\x0c\x06he\
ight\x0c\x04kind\x0b\x03\0\x05asset\x03\0\x0d\x01p\x01\x01p\x06\x01p\x0b\x01r\x03\
\x0bmedia-types\x0f\x0aunit-kinds\x10\x0basset-kinds\x11\x03\0\x15provider-capab\
ilities\x03\0\x12\x01p\x04\x01@\x02\x04kind\x01\x05querys\0\x14\x04\0\x0efetchme\
dialist\x01\x15\x01p\x09\x01@\x01\x07mediaids\0\x16\x04\0\x0afetchunits\x01\x17\x01\
p\x0e\x01@\x01\x06unitids\0\x18\x04\0\x0bfetchassets\x01\x19\x01@\0\0\x13\x04\0\x0f\
getcapabilities\x01\x1a\x04\0\x17touring:library/library\x04\0\x0b\x0d\x01\0\x07\
library\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.23\
8.0\x10wit-bindgen-rust\x060.45.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

