// Generated by `wit-bindgen` 0.45.0. DO NOT EDIT!
// Options used:
#[derive(Clone)]
pub enum MediaType {
    Anime,
    Manga,
    Other(_rt::String),
}
impl ::core::fmt::Debug for MediaType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            MediaType::Anime => f.debug_tuple("MediaType::Anime").finish(),
            MediaType::Manga => f.debug_tuple("MediaType::Manga").finish(),
            MediaType::Other(e) => f.debug_tuple("MediaType::Other").field(e).finish(),
        }
    }
}
#[derive(Clone)]
pub struct Media {
    pub id: _rt::String,
    pub mediatype: MediaType,
    pub title: _rt::String,
    pub description: Option<_rt::String>,
    pub url: Option<_rt::String>,
}
impl ::core::fmt::Debug for Media {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Media")
            .field("id", &self.id)
            .field("mediatype", &self.mediatype)
            .field("title", &self.title)
            .field("description", &self.description)
            .field("url", &self.url)
            .finish()
    }
}
/// Describes an anime episode
#[derive(Clone)]
pub struct Episode {
    pub id: _rt::String,
    pub title: _rt::String,
    /// Optional numeric episode number (e.g. 1, 12.5)
    pub number: Option<f32>,
    /// Optional link to the episode page on the provider
    pub url: Option<_rt::String>,
}
impl ::core::fmt::Debug for Episode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Episode")
            .field("id", &self.id)
            .field("title", &self.title)
            .field("number", &self.number)
            .field("url", &self.url)
            .finish()
    }
}
/// Describes a playable stream
#[derive(Clone)]
pub struct Mediastream {
    /// Direct or playlist URL (e.g. m3u8)
    pub url: _rt::String,
    /// Optional quality label (e.g. "1080p", "720p")
    pub quality: Option<_rt::String>,
    /// Optional MIME type (e.g. "application/vnd.apple.mpegurl", "video/mp4")
    pub mime: Option<_rt::String>,
}
impl ::core::fmt::Debug for Mediastream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Mediastream")
            .field("url", &self.url)
            .field("quality", &self.quality)
            .field("mime", &self.mime)
            .finish()
    }
}
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchmangalist_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        _rt::run_ctors_once();
        let result1 = {
            let len0 = arg1;
            let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
            T::fetchmangalist(_rt::string_lift(bytes0))
        };
        let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
        let vec9 = result1;
        let len9 = vec9.len();
        let layout9 = _rt::alloc::Layout::from_size_align(
            vec9.len() * (13 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        )
        .unwrap();
        let (result9, _cleanup9) = wit_bindgen::rt::Cleanup::new(layout9);
        if let Some(cleanup) = _cleanup9 {
            cleanup.forget();
        }
        for (i, e) in vec9.into_iter().enumerate() {
            let base = result9.add(i * (13 * ::core::mem::size_of::<*const u8>()));
            {
                let Media {
                    id: id3,
                    mediatype: mediatype3,
                    title: title3,
                    description: description3,
                    url: url3,
                } = e;
                let vec4 = (id3.into_bytes()).into_boxed_slice();
                let ptr4 = vec4.as_ptr().cast::<u8>();
                let len4 = vec4.len();
                ::core::mem::forget(vec4);
                *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len4;
                *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                match mediatype3 {
                    MediaType::Anime => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                    MediaType::Manga => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                    }
                    MediaType::Other(e) => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (2i32) as u8;
                        let vec5 = (e.into_bytes()).into_boxed_slice();
                        let ptr5 = vec5.as_ptr().cast::<u8>();
                        let len5 = vec5.len();
                        ::core::mem::forget(vec5);
                        *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len5;
                        *base
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr5.cast_mut();
                    }
                }
                let vec6 = (title3.into_bytes()).into_boxed_slice();
                let ptr6 = vec6.as_ptr().cast::<u8>();
                let len6 = vec6.len();
                ::core::mem::forget(vec6);
                *base
                    .add(6 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len6;
                *base
                    .add(5 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>() = ptr6.cast_mut();
                match description3 {
                    Some(e) => {
                        *base
                            .add(7 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        let vec7 = (e.into_bytes()).into_boxed_slice();
                        let ptr7 = vec7.as_ptr().cast::<u8>();
                        let len7 = vec7.len();
                        ::core::mem::forget(vec7);
                        *base
                            .add(9 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len7;
                        *base
                            .add(8 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr7.cast_mut();
                    }
                    None => {
                        *base
                            .add(7 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
                match url3 {
                    Some(e) => {
                        *base
                            .add(10 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        let vec8 = (e.into_bytes()).into_boxed_slice();
                        let ptr8 = vec8.as_ptr().cast::<u8>();
                        let len8 = vec8.len();
                        ::core::mem::forget(vec8);
                        *base
                            .add(12 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len8;
                        *base
                            .add(11 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr8.cast_mut();
                    }
                    None => {
                        *base
                            .add(10 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
            }
        }
        *ptr2
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>() = len9;
        *ptr2.add(0).cast::<*mut u8>() = result9;
        ptr2
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchmangalist<T: Guest>(arg0: *mut u8) {
    unsafe {
        let l0 = *arg0.add(0).cast::<*mut u8>();
        let l1 = *arg0
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>();
        let base15 = l0;
        let len15 = l1;
        for i in 0..len15 {
            let base = base15.add(i * (13 * ::core::mem::size_of::<*const u8>()));
            {
                let l2 = *base.add(0).cast::<*mut u8>();
                let l3 = *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l2, l3, 1);
                let l4 = i32::from(
                    *base
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l4 {
                    0 => (),
                    1 => (),
                    _ => {
                        let l5 = *base
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l6 = *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l5, l6, 1);
                    }
                }
                let l7 = *base
                    .add(5 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>();
                let l8 = *base
                    .add(6 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l7, l8, 1);
                let l9 = i32::from(
                    *base
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l9 {
                    0 => (),
                    _ => {
                        let l10 = *base
                            .add(8 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l11 = *base
                            .add(9 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l10, l11, 1);
                    }
                }
                let l12 = i32::from(
                    *base
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l12 {
                    0 => (),
                    _ => {
                        let l13 = *base
                            .add(11 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l14 = *base
                            .add(12 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l13, l14, 1);
                    }
                }
            }
        }
        _rt::cabi_dealloc(
            base15,
            len15 * (13 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        );
    }
}
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchchapterimages_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        _rt::run_ctors_once();
        let result1 = {
            let len0 = arg1;
            let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
            T::fetchchapterimages(_rt::string_lift(bytes0))
        };
        let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
        let vec4 = result1;
        let len4 = vec4.len();
        let layout4 = _rt::alloc::Layout::from_size_align(
            vec4.len() * (2 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        )
        .unwrap();
        let (result4, _cleanup4) = wit_bindgen::rt::Cleanup::new(layout4);
        if let Some(cleanup) = _cleanup4 {
            cleanup.forget();
        }
        for (i, e) in vec4.into_iter().enumerate() {
            let base = result4.add(i * (2 * ::core::mem::size_of::<*const u8>()));
            {
                let vec3 = (e.into_bytes()).into_boxed_slice();
                let ptr3 = vec3.as_ptr().cast::<u8>();
                let len3 = vec3.len();
                ::core::mem::forget(vec3);
                *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len3;
                *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
            }
        }
        *ptr2
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>() = len4;
        *ptr2.add(0).cast::<*mut u8>() = result4;
        ptr2
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchchapterimages<T: Guest>(arg0: *mut u8) {
    unsafe {
        let l0 = *arg0.add(0).cast::<*mut u8>();
        let l1 = *arg0
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>();
        let base4 = l0;
        let len4 = l1;
        for i in 0..len4 {
            let base = base4.add(i * (2 * ::core::mem::size_of::<*const u8>()));
            {
                let l2 = *base.add(0).cast::<*mut u8>();
                let l3 = *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l2, l3, 1);
            }
        }
        _rt::cabi_dealloc(
            base4,
            len4 * (2 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        );
    }
}
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchanimelist_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        _rt::run_ctors_once();
        let result1 = {
            let len0 = arg1;
            let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
            T::fetchanimelist(_rt::string_lift(bytes0))
        };
        let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
        let vec9 = result1;
        let len9 = vec9.len();
        let layout9 = _rt::alloc::Layout::from_size_align(
            vec9.len() * (13 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        )
        .unwrap();
        let (result9, _cleanup9) = wit_bindgen::rt::Cleanup::new(layout9);
        if let Some(cleanup) = _cleanup9 {
            cleanup.forget();
        }
        for (i, e) in vec9.into_iter().enumerate() {
            let base = result9.add(i * (13 * ::core::mem::size_of::<*const u8>()));
            {
                let Media {
                    id: id3,
                    mediatype: mediatype3,
                    title: title3,
                    description: description3,
                    url: url3,
                } = e;
                let vec4 = (id3.into_bytes()).into_boxed_slice();
                let ptr4 = vec4.as_ptr().cast::<u8>();
                let len4 = vec4.len();
                ::core::mem::forget(vec4);
                *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len4;
                *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                match mediatype3 {
                    MediaType::Anime => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                    MediaType::Manga => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                    }
                    MediaType::Other(e) => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (2i32) as u8;
                        let vec5 = (e.into_bytes()).into_boxed_slice();
                        let ptr5 = vec5.as_ptr().cast::<u8>();
                        let len5 = vec5.len();
                        ::core::mem::forget(vec5);
                        *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len5;
                        *base
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr5.cast_mut();
                    }
                }
                let vec6 = (title3.into_bytes()).into_boxed_slice();
                let ptr6 = vec6.as_ptr().cast::<u8>();
                let len6 = vec6.len();
                ::core::mem::forget(vec6);
                *base
                    .add(6 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len6;
                *base
                    .add(5 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>() = ptr6.cast_mut();
                match description3 {
                    Some(e) => {
                        *base
                            .add(7 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        let vec7 = (e.into_bytes()).into_boxed_slice();
                        let ptr7 = vec7.as_ptr().cast::<u8>();
                        let len7 = vec7.len();
                        ::core::mem::forget(vec7);
                        *base
                            .add(9 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len7;
                        *base
                            .add(8 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr7.cast_mut();
                    }
                    None => {
                        *base
                            .add(7 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
                match url3 {
                    Some(e) => {
                        *base
                            .add(10 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        let vec8 = (e.into_bytes()).into_boxed_slice();
                        let ptr8 = vec8.as_ptr().cast::<u8>();
                        let len8 = vec8.len();
                        ::core::mem::forget(vec8);
                        *base
                            .add(12 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len8;
                        *base
                            .add(11 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr8.cast_mut();
                    }
                    None => {
                        *base
                            .add(10 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
            }
        }
        *ptr2
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>() = len9;
        *ptr2.add(0).cast::<*mut u8>() = result9;
        ptr2
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchanimelist<T: Guest>(arg0: *mut u8) {
    unsafe {
        let l0 = *arg0.add(0).cast::<*mut u8>();
        let l1 = *arg0
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>();
        let base15 = l0;
        let len15 = l1;
        for i in 0..len15 {
            let base = base15.add(i * (13 * ::core::mem::size_of::<*const u8>()));
            {
                let l2 = *base.add(0).cast::<*mut u8>();
                let l3 = *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l2, l3, 1);
                let l4 = i32::from(
                    *base
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l4 {
                    0 => (),
                    1 => (),
                    _ => {
                        let l5 = *base
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l6 = *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l5, l6, 1);
                    }
                }
                let l7 = *base
                    .add(5 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>();
                let l8 = *base
                    .add(6 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l7, l8, 1);
                let l9 = i32::from(
                    *base
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l9 {
                    0 => (),
                    _ => {
                        let l10 = *base
                            .add(8 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l11 = *base
                            .add(9 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l10, l11, 1);
                    }
                }
                let l12 = i32::from(
                    *base
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l12 {
                    0 => (),
                    _ => {
                        let l13 = *base
                            .add(11 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l14 = *base
                            .add(12 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l13, l14, 1);
                    }
                }
            }
        }
        _rt::cabi_dealloc(
            base15,
            len15 * (13 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        );
    }
}
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchanimeepisodes_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        _rt::run_ctors_once();
        let result1 = {
            let len0 = arg1;
            let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
            T::fetchanimeepisodes(_rt::string_lift(bytes0))
        };
        let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
        let vec7 = result1;
        let len7 = vec7.len();
        let layout7 = _rt::alloc::Layout::from_size_align(
            vec7.len() * (8 + 7 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        )
        .unwrap();
        let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);
        if let Some(cleanup) = _cleanup7 {
            cleanup.forget();
        }
        for (i, e) in vec7.into_iter().enumerate() {
            let base = result7.add(i * (8 + 7 * ::core::mem::size_of::<*const u8>()));
            {
                let Episode {
                    id: id3,
                    title: title3,
                    number: number3,
                    url: url3,
                } = e;
                let vec4 = (id3.into_bytes()).into_boxed_slice();
                let ptr4 = vec4.as_ptr().cast::<u8>();
                let len4 = vec4.len();
                ::core::mem::forget(vec4);
                *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len4;
                *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                let vec5 = (title3.into_bytes()).into_boxed_slice();
                let ptr5 = vec5.as_ptr().cast::<u8>();
                let len5 = vec5.len();
                ::core::mem::forget(vec5);
                *base
                    .add(3 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len5;
                *base
                    .add(2 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>() = ptr5.cast_mut();
                match number3 {
                    Some(e) => {
                        *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        *base
                            .add(4 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<f32>() = _rt::as_f32(e);
                    }
                    None => {
                        *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
                match url3 {
                    Some(e) => {
                        *base
                            .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        let vec6 = (e.into_bytes()).into_boxed_slice();
                        let ptr6 = vec6.as_ptr().cast::<u8>();
                        let len6 = vec6.len();
                        ::core::mem::forget(vec6);
                        *base
                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len6;
                        *base
                            .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr6.cast_mut();
                    }
                    None => {
                        *base
                            .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
            }
        }
        *ptr2
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>() = len7;
        *ptr2.add(0).cast::<*mut u8>() = result7;
        ptr2
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchanimeepisodes<T: Guest>(arg0: *mut u8) {
    unsafe {
        let l0 = *arg0.add(0).cast::<*mut u8>();
        let l1 = *arg0
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>();
        let base9 = l0;
        let len9 = l1;
        for i in 0..len9 {
            let base = base9.add(i * (8 + 7 * ::core::mem::size_of::<*const u8>()));
            {
                let l2 = *base.add(0).cast::<*mut u8>();
                let l3 = *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l2, l3, 1);
                let l4 = *base
                    .add(2 * ::core::mem::size_of::<*const u8>())
                    .cast::<*mut u8>();
                let l5 = *base
                    .add(3 * ::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l4, l5, 1);
                let l6 = i32::from(
                    *base
                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l6 {
                    0 => (),
                    _ => {
                        let l7 = *base
                            .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l8 = *base
                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l7, l8, 1);
                    }
                }
            }
        }
        _rt::cabi_dealloc(
            base9,
            len9 * (8 + 7 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        );
    }
}
#[doc(hidden)]
#[allow(non_snake_case, unused_unsafe)]
pub unsafe fn _export_fetchepisodestreams_cabi<T: Guest>(arg0: *mut u8, arg1: usize) -> *mut u8 {
    unsafe {
        #[cfg(target_arch = "wasm32")]
        _rt::run_ctors_once();
        let result1 = {
            let len0 = arg1;
            let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
            T::fetchepisodestreams(_rt::string_lift(bytes0))
        };
        let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
        let vec7 = result1;
        let len7 = vec7.len();
        let layout7 = _rt::alloc::Layout::from_size_align(
            vec7.len() * (8 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        )
        .unwrap();
        let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);
        if let Some(cleanup) = _cleanup7 {
            cleanup.forget();
        }
        for (i, e) in vec7.into_iter().enumerate() {
            let base = result7.add(i * (8 * ::core::mem::size_of::<*const u8>()));
            {
                let Mediastream {
                    url: url3,
                    quality: quality3,
                    mime: mime3,
                } = e;
                let vec4 = (url3.into_bytes()).into_boxed_slice();
                let ptr4 = vec4.as_ptr().cast::<u8>();
                let len4 = vec4.len();
                ::core::mem::forget(vec4);
                *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>() = len4;
                *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                match quality3 {
                    Some(e) => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        let vec5 = (e.into_bytes()).into_boxed_slice();
                        let ptr5 = vec5.as_ptr().cast::<u8>();
                        let len5 = vec5.len();
                        ::core::mem::forget(vec5);
                        *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len5;
                        *base
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr5.cast_mut();
                    }
                    None => {
                        *base
                            .add(2 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
                match mime3 {
                    Some(e) => {
                        *base
                            .add(5 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (1i32) as u8;
                        let vec6 = (e.into_bytes()).into_boxed_slice();
                        let ptr6 = vec6.as_ptr().cast::<u8>();
                        let len6 = vec6.len();
                        ::core::mem::forget(vec6);
                        *base
                            .add(7 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>() = len6;
                        *base
                            .add(6 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>() = ptr6.cast_mut();
                    }
                    None => {
                        *base
                            .add(5 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>() = (0i32) as u8;
                    }
                };
            }
        }
        *ptr2
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>() = len7;
        *ptr2.add(0).cast::<*mut u8>() = result7;
        ptr2
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_fetchepisodestreams<T: Guest>(arg0: *mut u8) {
    unsafe {
        let l0 = *arg0.add(0).cast::<*mut u8>();
        let l1 = *arg0
            .add(::core::mem::size_of::<*const u8>())
            .cast::<usize>();
        let base10 = l0;
        let len10 = l1;
        for i in 0..len10 {
            let base = base10.add(i * (8 * ::core::mem::size_of::<*const u8>()));
            {
                let l2 = *base.add(0).cast::<*mut u8>();
                let l3 = *base
                    .add(::core::mem::size_of::<*const u8>())
                    .cast::<usize>();
                _rt::cabi_dealloc(l2, l3, 1);
                let l4 = i32::from(
                    *base
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l4 {
                    0 => (),
                    _ => {
                        let l5 = *base
                            .add(3 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l6 = *base
                            .add(4 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l5, l6, 1);
                    }
                }
                let l7 = i32::from(
                    *base
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>(),
                );
                match l7 {
                    0 => (),
                    _ => {
                        let l8 = *base
                            .add(6 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l9 = *base
                            .add(7 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        _rt::cabi_dealloc(l8, l9, 1);
                    }
                }
            }
        }
        _rt::cabi_dealloc(
            base10,
            len10 * (8 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        );
    }
}
pub trait Guest {
    /// Fetch a list of manga by query
    #[allow(async_fn_in_trait)]
    fn fetchmangalist(query: _rt::String) -> _rt::Vec<Media>;
    /// Fetch all image URLs for a given chapter
    #[allow(async_fn_in_trait)]
    fn fetchchapterimages(chapterid: _rt::String) -> _rt::Vec<_rt::String>;
    /// Fetch a list of anime by query
    #[allow(async_fn_in_trait)]
    fn fetchanimelist(query: _rt::String) -> _rt::Vec<Media>;
    /// Fetch all episodes for a given anime id
    #[allow(async_fn_in_trait)]
    fn fetchanimeepisodes(animeid: _rt::String) -> _rt::Vec<Episode>;
    /// Fetch available stream URLs for a given episode id
    #[allow(async_fn_in_trait)]
    fn fetchepisodestreams(episodeid: _rt::String) -> _rt::Vec<Mediastream>;
}
#[doc(hidden)]

macro_rules! __export_world_source_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[unsafe(export_name = "fetchmangalist")]
    unsafe extern "C" fn export_fetchmangalist(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchmangalist_cabi::<$ty>(arg0, arg1) }
    }
    #[unsafe(export_name = "cabi_post_fetchmangalist")]
    unsafe extern "C" fn _post_return_fetchmangalist(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchmangalist::<$ty>(arg0) }
    }
    #[unsafe(export_name = "fetchchapterimages")]
    unsafe extern "C" fn export_fetchchapterimages(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchchapterimages_cabi::<$ty>(arg0, arg1) }
    }
    #[unsafe(export_name = "cabi_post_fetchchapterimages")]
    unsafe extern "C" fn _post_return_fetchchapterimages(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchchapterimages::<$ty>(arg0) }
    }
    #[unsafe(export_name = "fetchanimelist")]
    unsafe extern "C" fn export_fetchanimelist(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchanimelist_cabi::<$ty>(arg0, arg1) }
    }
    #[unsafe(export_name = "cabi_post_fetchanimelist")]
    unsafe extern "C" fn _post_return_fetchanimelist(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchanimelist::<$ty>(arg0) }
    }
    #[unsafe(export_name = "fetchanimeepisodes")]
    unsafe extern "C" fn export_fetchanimeepisodes(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchanimeepisodes_cabi::<$ty>(arg0, arg1) }
    }
    #[unsafe(export_name = "cabi_post_fetchanimeepisodes")]
    unsafe extern "C" fn _post_return_fetchanimeepisodes(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchanimeepisodes::<$ty>(arg0) }
    }
    #[unsafe(export_name = "fetchepisodestreams")]
    unsafe extern "C" fn export_fetchepisodestreams(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      unsafe { $($path_to_types)*::_export_fetchepisodestreams_cabi::<$ty>(arg0, arg1) }
    }
    #[unsafe(export_name = "cabi_post_fetchepisodestreams")]
    unsafe extern "C" fn _post_return_fetchepisodestreams(arg0: *mut u8,) {
      unsafe { $($path_to_types)*::__post_return_fetchepisodestreams::<$ty>(arg0) }
    }
  };);
}
#[doc(hidden)]
pub(crate) use __export_world_source_cabi;

#[cfg_attr(target_pointer_width = "64", repr(align(8)))]
#[cfg_attr(target_pointer_width = "32", repr(align(4)))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 2 * ::core::mem::size_of::<*const u8>()]);
static mut _RET_AREA: _RetArea =
    _RetArea([::core::mem::MaybeUninit::uninit(); 2 * ::core::mem::size_of::<*const u8>()]);
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;

    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen::rt::run_ctors_once();
    }
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            unsafe { String::from_utf8_unchecked(bytes) }
        }
    }
    pub use alloc_crate::alloc;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        unsafe {
            let layout = alloc::Layout::from_size_align_unchecked(size, align);
            alloc::dealloc(ptr, layout);
        }
    }

    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }

    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }

    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }

    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_source_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::__export_world_source_cabi!($ty with_types_in $($path_to_types_root)*);
  )
}
#[doc(inline)]
pub(crate) use __export_source_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.45.0:touring:source:source:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 519] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x8a\x03\x01A\x02\x01\
A\x17\x01q\x03\x05anime\0\0\x05manga\0\0\x05other\x01s\0\x03\0\x0amedia-type\x03\
\0\0\x01ks\x01r\x05\x02ids\x09mediatype\x01\x05titles\x0bdescription\x02\x03url\x02\
\x03\0\x05media\x03\0\x03\x01kv\x01r\x04\x02ids\x05titles\x06number\x05\x03url\x02\
\x03\0\x07episode\x03\0\x06\x01r\x03\x03urls\x07quality\x02\x04mime\x02\x03\0\x0b\
mediastream\x03\0\x08\x01p\x04\x01@\x01\x05querys\0\x0a\x04\0\x0efetchmangalist\x01\
\x0b\x01ps\x01@\x01\x09chapterids\0\x0c\x04\0\x12fetchchapterimages\x01\x0d\x04\0\
\x0efetchanimelist\x01\x0b\x01p\x07\x01@\x01\x07animeids\0\x0e\x04\0\x12fetchani\
meepisodes\x01\x0f\x01p\x09\x01@\x01\x09episodeids\0\x10\x04\0\x13fetchepisodest\
reams\x01\x11\x04\0\x15touring:source/source\x04\0\x0b\x0c\x01\0\x06source\x03\0\
\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.238.0\x10wit-bi\
ndgen-rust\x060.45.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
